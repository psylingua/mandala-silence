<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>PsyLingua – Mandala du silence</title>

  <style>
    :root{
      --gap:10px;
      --btn:42px;
      --radius:10px;
      --border:#cfcfcf;
    }
    body{ margin:0; background:#fff; font-family: Arial, sans-serif; }
    .wrap{
      width:100%;
      max-width:980px;
      margin:0 auto;
      padding:10px 10px 14px;
      box-sizing:border-box;
      text-align:center;
    }
    .toolbar{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:var(--gap);
      flex-wrap:wrap;
      margin:6px auto 10px;
      user-select:none;
    }
    .color-input{
      width:54px; height:var(--btn);
      border:1px solid var(--border);
      border-radius:var(--radius);
      padding:0; background:#fff; cursor:pointer;
    }
    .swatches{
      display:flex; gap:8px; align-items:center;
      padding:6px 10px;
      border:1px solid var(--border);
      border-radius:var(--radius);
      background:#fff;
    }
    .swatch{
      width:22px; height:22px;
      border-radius:50%;
      border:1px solid #bbb;
      cursor:pointer;
    }
    .btn{
      width:var(--btn); height:var(--btn);
      border:1px solid var(--border);
      border-radius:var(--radius);
      background:#fff; cursor:pointer;
      display:flex; align-items:center; justify-content:center;
    }
    .btn.active{ outline:2px solid #111; outline-offset:1px; }
    .btn svg{ width:22px; height:22px; display:block; }

    .stage{
      width:100%;
      border:1px solid #e6e6e6;
      border-radius:14px;
      overflow:hidden;
      background:#fff;
    }
    .canvas-stack{
      position:relative;
      width:100%;
      aspect-ratio: 1000 / 650;
      background:#fff;
    }
    canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      touch-action:none;
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="toolbar">
      <input class="color-input" type="color" id="colorPicker" value="#ff3b30" title="Couleur / Color"/>

      <div class="swatches" title="Couleurs rapides / Quick colors">
        <div class="swatch" data-c="#ff3b30" style="background:#ff3b30"></div>
        <div class="swatch" data-c="#ff9500" style="background:#ff9500"></div>
        <div class="swatch" data-c="#ffcc00" style="background:#ffcc00"></div>
        <div class="swatch" data-c="#34c759" style="background:#34c759"></div>
        <div class="swatch" data-c="#007aff" style="background:#007aff"></div>
        <div class="swatch" data-c="#af52de" style="background:#af52de"></div>
        <div class="swatch" data-c="#000000" style="background:#000000"></div>
      </div>

      <!-- Pinceau -->
      <button class="btn active" id="btnBrush" title="Pinceau / Brush">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M3 21c3.5 0 6-2 6-5 0-1.1.9-2 2-2h1l9-9-3-3-9 9v1c0 1.1-.9 2-2 2-3 0-5 2.5-5 6z" fill="#111"/>
        </svg>
      </button>

      <!-- Pot -->
      <button class="btn" id="btnFill" title="Pot de peinture / Fill">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M7 3h10v6H7V3z" fill="#111"/>
          <path d="M9 9h6l3 11H6L9 9z" fill="#111"/>
          <circle cx="6" cy="20" r="2" fill="#111"/>
        </svg>
      </button>

      <!-- Gomme -->
      <button class="btn" id="btnEraser" title="Gomme / Eraser">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M16 3l5 5-10 10H6l-3-3 13-12z" fill="#111"/>
          <path d="M6 18h15v3H6v-3z" fill="#111"/>
        </svg>
      </button>

      <!-- Tout effacer -->
      <button class="btn" id="btnClear" title="Tout effacer / Clear all">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M7 6h10l-1 16H8L7 6z" fill="#111"/>
          <path d="M9 4h6l1 2H8l1-2z" fill="#111"/>
        </svg>
      </button>

      <!-- Imprimer -->
      <button class="btn" id="btnPrint" title="Imprimer / Print">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M7 8V3h10v5H7z" fill="#111"/>
          <path d="M6 9h12a3 3 0 013 3v5h-4v4H7v-4H3v-5a3 3 0 013-3z" fill="#111"/>
          <rect x="8.5" y="14.5" width="7" height="5" fill="#fff"/>
        </svg>
      </button>
    </div>

    <div class="stage">
      <div class="canvas-stack">
        <canvas id="baseCanvas"></canvas>
        <canvas id="paintCanvas"></canvas>
      </div>
    </div>

  </div>

<script>
(() => {
  const W = 1000, H = 650;

  const baseCanvas = document.getElementById("baseCanvas");
  const paintCanvas = document.getElementById("paintCanvas");
  baseCanvas.width = paintCanvas.width = W;
  baseCanvas.height = paintCanvas.height = H;

  const bctx = baseCanvas.getContext("2d", { willReadFrequently: true });
  const pctx = paintCanvas.getContext("2d", { willReadFrequently: true });

  const colorPicker = document.getElementById("colorPicker");
  const swatches = document.querySelectorAll(".swatch");

  const btnBrush = document.getElementById("btnBrush");
  const btnFill  = document.getElementById("btnFill");
  const btnEraser= document.getElementById("btnEraser");
  const btnClear = document.getElementById("btnClear");
  const btnPrint = document.getElementById("btnPrint");

  let tool = "brush";
  let drawing = false;
  let lastX = 0, lastY = 0;

  const brushSize = 5;
  const eraserSize = 14;

  // --- Mandala + bbox ---
  const mandala = new Image();
  mandala.src = "mandala.png";

  let mandalaData = null;
  let bbox = {x0:0,y0:0,x1:W-1,y1:H-1}; // zone dans laquelle le pot a le droit d’agir

  mandala.onload = () => {
    bctx.clearRect(0,0,W,H);
    bctx.fillStyle="#fff";
    bctx.fillRect(0,0,W,H);

    const fit = containFit(mandala.width, mandala.height, W, H);
    bctx.drawImage(mandala, fit.dx, fit.dy, fit.dw, fit.dh);

    // bbox = zone exacte où le mandala est dessiné (le pot ne sort JAMAIS de là)
    bbox = {
      x0: fit.dx,
      y0: fit.dy,
      x1: fit.dx + fit.dw - 1,
      y1: fit.dy + fit.dh - 1
    };

    mandalaData = bctx.getImageData(0,0,W,H);
  };

  function containFit(imgW, imgH, boxW, boxH){
    const rImg = imgW / imgH;
    const rBox = boxW / boxH;
    let dw, dh, dx, dy;
    if (rImg > rBox){
      dw = boxW;
      dh = Math.round(boxW / rImg);
      dx = 0;
      dy = Math.round((boxH - dh)/2);
    } else {
      dh = boxH;
      dw = Math.round(boxH * rImg);
      dy = 0;
      dx = Math.round((boxW - dw)/2);
    }
    return {dx, dy, dw, dh};
  }

  // --- UI active ---
  function setActive(btn){
    [btnBrush, btnFill, btnEraser].forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
  }
  btnBrush.addEventListener("click", () => { tool="brush"; setActive(btnBrush); });
  btnFill.addEventListener("click",  () => { tool="fill";  setActive(btnFill);  });
  btnEraser.addEventListener("click",() => { tool="eraser";setActive(btnEraser);});

  btnClear.addEventListener("click", () => {
    // Efface UNIQUEMENT la couche de couleur
    pctx.clearRect(0,0,W,H);
  });

  btnPrint.addEventListener("click", () => printMerged());

  swatches.forEach(s => {
    s.addEventListener("click", () => colorPicker.value = s.dataset.c);
  });

  // --- Coords ---
  function getPos(e){
    const rect = paintCanvas.getBoundingClientRect();
    const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
    const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
    const x = (clientX - rect.left) * (W / rect.width);
    const y = (clientY - rect.top) * (H / rect.height);
    return {x, y};
  }

  // --- Events ---
  function start(e){
    e.preventDefault();
    const {x,y} = getPos(e);
    lastX = x; lastY = y;

    if (tool === "fill"){
      doFill(Math.floor(x), Math.floor(y));
      drawing = false;
      return;
    }

    drawing = true;

    if (tool === "brush"){
      pctx.beginPath();
      pctx.moveTo(lastX, lastY);
    }
  }

  function move(e){
    if (!drawing) return;
    e.preventDefault();
    const {x,y} = getPos(e);

    if (tool === "brush"){
      pctx.globalCompositeOperation = "source-over";
      pctx.strokeStyle = colorPicker.value;
      pctx.lineWidth = brushSize;
      pctx.lineCap = "round";
      pctx.lineJoin = "round";
      pctx.lineTo(x, y);
      pctx.stroke();
      lastX = x; lastY = y;
      return;
    }

    if (tool === "eraser"){
      // gomme = efface seulement la couleur
      pctx.globalCompositeOperation = "destination-out";
      pctx.beginPath();
      pctx.arc(x, y, eraserSize, 0, Math.PI*2);
      pctx.fill();
      pctx.globalCompositeOperation = "source-over";
    }
  }

  function end(){
    drawing = false;
    pctx.beginPath();
  }

  ["mousedown","touchstart"].forEach(evt => paintCanvas.addEventListener(evt, start, {passive:false}));
  ["mousemove","touchmove"].forEach(evt => paintCanvas.addEventListener(evt, move,  {passive:false}));
  ["mouseup","mouseleave","touchend","touchcancel"].forEach(evt => paintCanvas.addEventListener(evt, end));

  // --- Pot de peinture : ultra sécurisé ---
  function insideBbox(x,y){
    return (x>=bbox.x0 && x<=bbox.x1 && y>=bbox.y0 && y<=bbox.y1);
  }

  function doFill(x, y){
    if (!mandalaData) return;

    // Important : si on clique hors du mandala → on ne remplit pas toute la page
    if (!insideBbox(x,y)) return;

    // si clic sur un trait → rien
    if (isMandalaLine(x,y)) return;

    const img = pctx.getImageData(0,0,W,H);
    const fillColor = hexToRgba(colorPicker.value);
    const target = getPixel(img, x, y);

    // si déjà même couleur
    if (colorsMatch(target, fillColor)) return;

    floodFill(img, x, y, target, fillColor);
    pctx.putImageData(img, 0, 0);
  }

  // Barrière = soit hors bbox, soit pixel du mandala “sombre” (inclut le gris anti-alias)
  function isBarrier(x,y){
    if (!insideBbox(x,y)) return true;
    return isMandalaLine(x,y);
  }

  function isMandalaLine(x,y){
    const i = (y*W + x)*4;
    const r = mandalaData.data[i], g = mandalaData.data[i+1], b = mandalaData.data[i+2];

    // seuil plus haut pour attraper les bords gris (anti-alias)
    const lum = 0.2126*r + 0.7152*g + 0.0722*b;
    return lum < 230; // ⬅️ crucial : empêche la “fuite” du pot
  }

  function floodFill(img, x, y, target, fill){
    const stack = [[x,y]];
    const visited = new Uint8Array(W*H);

    while(stack.length){
      const [cx, cy] = stack.pop();
      if (cx<0 || cy<0 || cx>=W || cy>=H) continue;

      const idx = cy*W + cx;
      if (visited[idx]) continue;
      visited[idx] = 1;

      if (isBarrier(cx,cy)) continue;

      const cur = getPixel(img, cx, cy);
      if (!colorsMatch(cur, target)) continue;

      setPixel(img, cx, cy, fill);

      stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
    }
  }

  function getPixel(img, x, y){
    const i = (y*W + x)*4;
    return [img.data[i], img.data[i+1], img.data[i+2], img.data[i+3]];
  }
  function setPixel(img, x, y, c){
    const i = (y*W + x)*4;
    img.data[i]   = c[0];
    img.data[i+1] = c[1];
    img.data[i+2] = c[2];
    img.data[i+3] = 255;
  }
  function colorsMatch(a,b){
    return a[0]===b[0] && a[1]===b[1] && a[2]===b[2] && a[3]===b[3];
  }
  function hexToRgba(hex){
    const v = parseInt(hex.slice(1),16);
    return [(v>>16)&255, (v>>8)&255, v&255, 255];
  }

  // --- Impression : fusion base + peinture ---
  function printMerged(){
    const tmp = document.createElement("canvas");
    tmp.width = W; tmp.height = H;
    const tctx = tmp.getContext("2d");

    tctx.fillStyle="#fff";
    tctx.fillRect(0,0,W,H);
    tctx.drawImage(baseCanvas, 0, 0);
    tctx.drawImage(paintCanvas, 0, 0);

    const win = window.open("");
    win.document.write("<img style='max-width:100%;height:auto' src='"+ tmp.toDataURL("image/png") +"'/>");
    win.document.close();
    win.focus();
    win.print();
    win.close();
  }

})();
</script>
</body>
</html>
