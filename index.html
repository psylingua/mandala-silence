<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>PsyLingua ‚Äì Mandala du silence</title>

<style>
  body {
    margin: 0;
    padding: 0;
    background: #ffffff;
    font-family: Arial, sans-serif;
    text-align: center;
  }

  #toolbar {
    margin: 10px auto;
  }

  button {
    font-size: 18px;
    margin: 0 4px;
    padding: 6px 10px;
    cursor: pointer;
  }

  canvas {
    display: block;
    margin: 0 auto;
    cursor: crosshair;
  }
</style>
</head>

<body>

<!-- OUTILS -->
<div id="toolbar">
  <input type="color" id="colorPicker" value="#ff0000">
  <button onclick="setTool('brush')" title="Pinceau / Brush">‚úèÔ∏è</button>
  <button onclick="setTool('fill')" title="Remplir / Fill">ü™£</button>
  <button onclick="setTool('eraser')" title="Gomme / Eraser">üßΩ</button>
  <button onclick="printCanvas()" title="Imprimer / Print">üñ®Ô∏è</button>
</div>

<!-- CANVAS -->
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const mandala = new Image();
mandala.src = "mandala.png";

let tool = "brush";
let drawing = false;
let brushSize = 6;

// TAILLE CANVAS (adapt√©e Genially)
canvas.width = 1200;
canvas.height = 760;

mandala.onload = () => {
  ctx.drawImage(mandala, 0, 0, canvas.width, canvas.height);
};

// OUTILS
function setTool(t) {
  tool = t;
}

// SOURIS
canvas.addEventListener("mousedown", e => {
  drawing = true;
  if (tool === "fill") fill(e);
});

canvas.addEventListener("mouseup", () => drawing = false);
canvas.addEventListener("mouseleave", () => drawing = false);

canvas.addEventListener("mousemove", e => {
  if (!drawing || tool !== "brush") return;
  draw(e);
});

// DESSIN
function draw(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  ctx.globalCompositeOperation = "source-over";
  ctx.strokeStyle = document.getElementById("colorPicker").value;
  ctx.lineWidth = brushSize;
  ctx.lineCap = "round";

  ctx.lineTo(x, y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y);
}

// REMPLISSAGE
function fill(e) {
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor(e.clientX - rect.left);
  const y = Math.floor(e.clientY - rect.top);

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const targetColor = getPixel(imageData, x, y);
  const fillColor = hexToRgba(document.getElementById("colorPicker").value);

  if (colorsMatch(targetColor, fillColor)) return;

  floodFill(imageData, x, y, targetColor, fillColor);
  ctx.putImageData(imageData, 0, 0);
}

// GOMME (N‚Äôefface PAS le mandala)
canvas.addEventListener("mousedown", e => {
  if (tool !== "eraser") return;
  drawing = true;
});

canvas.addEventListener("mousemove", e => {
  if (!drawing || tool !== "eraser") return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  ctx.globalCompositeOperation = "destination-out";
  ctx.beginPath();
  ctx.arc(x, y, 8, 0, Math.PI * 2);
  ctx.fill();
});

canvas.addEventListener("mouseup", () => {
  ctx.globalCompositeOperation = "source-over";
});

// IMPRIMER
function printCanvas() {
  const win = window.open();
  win.document.write("<img src='" + canvas.toDataURL() + "'/>");
  win.document.close();
  win.focus();
  win.print();
  win.close();
}

// UTILITAIRES
function getPixel(img, x, y) {
  const i = (y * img.width + x) * 4;
  return [img.data[i], img.data[i+1], img.data[i+2], img.data[i+3]];
}

function setPixel(img, x, y, color) {
  const i = (y * img.width + x) * 4;
  img.data[i] = color[0];
  img.data[i+1] = color[1];
  img.data[i+2] = color[2];
  img.data[i+3] = 255;
}

function colorsMatch(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

function hexToRgba(hex) {
  const bigint = parseInt(hex.slice(1), 16);
  return [
    (bigint >> 16) & 255,
    (bigint >> 8) & 255,
    bigint & 255,
    255
  ];
}

function floodFill(img, x, y, target, fill) {
  const stack = [[x, y]];

  while (stack.length) {
    const [cx, cy] = stack.pop();
    if (cx < 0 || cy < 0 || cx >= img.width || cy >= img.height) continue;

    const current = getPixel(img, cx, cy);
    if (!colorsMatch(current, target)) continue;

    setPixel(img, cx, cy, fill);
    stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
  }
}
</script>

</body>
</html>
